"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3592],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),f=a,h=u["".concat(c,".").concat(f)]||u[f]||d[f]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},57736:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={id:"self-repair",title:"Self Repair"},o=void 0,s={unversionedId:"learn/p2p/self-repair",id:"learn/p2p/self-repair",title:"Self Repair",description:"Archethic Blockchain is using a self-repair mechanism to be able to sync/re-sync missing transactions to be able",source:"@site/docs/learn/p2p/self-repair.md",sourceDirName:"learn/p2p",slug:"/learn/p2p/self-repair",permalink:"/archethic-docs/learn/p2p/self-repair",tags:[],version:"current",lastUpdatedAt:1656681727,formattedLastUpdatedAt:"7/1/2022",frontMatter:{id:"self-repair",title:"Self Repair"},sidebar:"docs",previous:{title:"Bootstrapping",permalink:"/archethic-docs/learn/p2p/bootstrapping"},next:{title:"OracleChain",permalink:"/archethic-docs/learn/oracle-chain"}},c=[{value:"Identification",id:"identification",children:[],level:2},{value:"Synchronization",id:"synchronization",children:[],level:2}],l={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Archethic Blockchain is using a self-repair mechanism to be able to sync/re-sync missing transactions to be able\nto restore the state of a node."),(0,a.kt)("p",null,"Because Archethic is using a multidimensional sharding, a node needs to execute a self-repair on multiple occasions, to ensure data availability and security:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When the node bootstrap"),(0,a.kt)("li",{parentName:"ul"},"When a node goes offline"),(0,a.kt)("li",{parentName:"ul"},"When the code and heuristic algorithms changes")),(0,a.kt)("h2",{id:"identification"},"Identification"),(0,a.kt)("p",null,"To be able to determine which transactions are missing, for each cycle of repair, a date of last sync is persisted.\nTherefore, we can decide from this date, the list of missing BeaconChain transactions to sync. (Reminder: BeaconChain summaries transactions across the entire network each day)"),(0,a.kt)("p",null,"The Self-Repair will then request BeaconChain storage pools to get the missing transactions from those missing days"),(0,a.kt)("h2",{id:"synchronization"},"Synchronization"),(0,a.kt)("p",null,"Because we are using rotating election, nodes need to perform the ",(0,a.kt)("inlineCode",{parentName:"p"},"Storage Node Election")," to determine if they need to store this transaction."),(0,a.kt)("p",null,"In that case, we will get the list of existing storage nodes from the transaction's address to sync and request from the closest nodes the transaction to be replicated."),(0,a.kt)("p",null,"Once finalized, a new last date of sync is persisted for the next cycle."))}p.isMDXComponent=!0}}]);