"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7945],{1656:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>i,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var r=n(7462),a=(n(7294),n(3905));n(1839);const s={id:"examples",title:"Smart Contract examples",sidebar_label:"Examples"},o=void 0,c={unversionedId:"build/smart-contracts/examples",id:"build/smart-contracts/examples",title:"Smart Contract examples",description:"Recurrent transfer",source:"@site/docs/build/smart-contracts/examples.md",sourceDirName:"build/smart-contracts",slug:"/build/smart-contracts/examples",permalink:"/archethic-docs/build/smart-contracts/examples",draft:!1,tags:[],version:"current",lastUpdatedAt:1669394464,formattedLastUpdatedAt:"Nov 25, 2022",frontMatter:{id:"examples",title:"Smart Contract examples",sidebar_label:"Examples"},sidebar:"docs",previous:{title:"Smart Contracts",permalink:"/archethic-docs/build/smart-contracts/"},next:{title:"Language",permalink:"/archethic-docs/build/smart-contracts/language"}},i={},d=[{value:"Recurrent transfer",id:"recurrent-transfer",level:2},{value:"ICO / Crowdfunding",id:"ico--crowdfunding",level:2}],l={toc:d};function u(t){let{components:e,...n}=t;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"recurrent-transfer"},"Recurrent transfer"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'# Send 1.0 each to the given address each month\n\ncondition inherit: [\n  type: transfer,\n  uco_transfers: [\n     %{ "0000D574D171A484F8DEAC2D61FC3F7CC984BEB52465D69B3B5F670090742CBF5CCA" => 100000000 }\n  ]\n]\n\nactions triggered_by: interval, at: "0 0 1 * *" do\n  set_type transfer\n  add_uco_transfer to: "0000D574D171A484F8DEAC2D61FC3F7CC984BEB52465D69B3B5F670090742CBF5CCA", amount: 100000000\nend\n')),(0,a.kt)("h2",{id:"ico--crowdfunding"},"ICO / Crowdfunding"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\n# Ensure the next transaction will be a transfer\ncondition inherit: [\n  type: transfer,\n  token_transfers: size() == 1\n  # TODO: to provide more security, we should check the destination address is within the previous transaction inputs\n]\n\n# Define conditions to accept incoming transactions\ncondition transaction: [\n  type: transfer,\n  uco_transfers: size() > 0\n]\n\nactions triggered_by: transaction do\n  # Get the amount of uco send to this contract\n  amount_send = transaction.uco_transfers[contract.address]\n\n  if amount_send > 0 do\n      # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n      token_to_credit = amount_send * 10000\n\n      # Send the new transaction\n      set_type transfer\n      add_token_transfer to: transaction.address, token_address: contract.address, amount: token_to_credit\n  end\nend\n")))}u.isMDXComponent=!0}}]);