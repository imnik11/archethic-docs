"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7945],{1656:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>i,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var r=e(7462),a=(e(7294),e(3905));e(1839);const s={id:"examples",title:"Smart Contract examples"},o=void 0,c={unversionedId:"build/smart-contracts/examples",id:"build/smart-contracts/examples",title:"Smart Contract examples",description:"Recurrent transfer",source:"@site/docs/build/smart-contracts/examples.md",sourceDirName:"build/smart-contracts",slug:"/build/smart-contracts/examples",permalink:"/archethic-docs/build/smart-contracts/examples",draft:!1,tags:[],version:"current",lastUpdatedAt:1662387602,formattedLastUpdatedAt:"Sep 5, 2022",frontMatter:{id:"examples",title:"Smart Contract examples"},sidebar:"docs",previous:{title:"Smart Contract Language",permalink:"/archethic-docs/build/smart-contracts/language"},next:{title:"Javascript SDK",permalink:"/archethic-docs/build/sdk/js"}},i={},d=[{value:"Recurrent transfer",id:"recurrent-transfer",level:2},{value:"ICO / Crowdfunding",id:"ico--crowdfunding",level:2}],u={toc:d};function l(t){let{components:n,...e}=t;return(0,a.kt)("wrapper",(0,r.Z)({},u,e,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"recurrent-transfer"},"Recurrent transfer"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'# Send 1.0 each to the given address each month\n\ncondition inherit: [\n  type: transfer,\n  uco_transfers: [\n     %{ to: "0000D574D171A484F8DEAC2D61FC3F7CC984BEB52465D69B3B5F670090742CBF5CC", amount: 100000000 }\n  ]\n]\n\nactions triggered_by: interval, at: "0 0 1 * *" do\n  set_type transfer\n  add_uco_transfer to: "0000D574D171A484F8DEAC2D61FC3F7CC984BEB52465D69B3B5F670090742CBF5CC", amount: 100000000\nend\n')),(0,a.kt)("h2",{id:"ico--crowdfunding"},"ICO / Crowdfunding"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"\n# Ensure the next transaction will be a transfer\ncondition inherit: [\n  type: transfer,\n  token_transfers: size() == 1\n  # TODO: to provide more security, we should check the destination address is within the previous transaction inputs \n]\n\n# Define conditions to accept incoming transactions\ncondition transaction: [\n  type: transfer, \n  uco_transfers: size() > 0\n] \n\nactions triggered_by: transaction do\n  # Get the amount of uco send to this contract\n  amount_send = transaction.uco_transfers[contract.address]\n\n  if amount_send > 0 do\n      # Convert UCO to the number of tokens to credit. Each UCO worth 10000 token\n      token_to_credit = amount_send * 10000 \n\n      # Send the new transaction\n      set_type transfer\n      add_token_transfer to: transaction.address, token_address: contract.address, amount: token_to_credit\n  end \nend\n")))}l.isMDXComponent=!0}}]);